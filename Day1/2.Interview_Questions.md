# Next.js Interview Questions & Answers
> With Code Examples & Real-World Scenarios

---

## üìå BASICS

---

### Q1. What is Next.js and why would you use it over plain React?

**Answer:**
Next.js is a **React framework** built by Vercel that adds production-ready features on top of React like:
- Server-Side Rendering (SSR)
- Static Site Generation (SSG)
- File-based routing
- API Routes
- Image & Font Optimization
- Built-in SEO support

**Real-World Scenario:**
> You're building an e-commerce site. Plain React renders everything on the client ‚Äî search engines can't crawl your product pages. With Next.js + SSR/SSG, product pages are pre-rendered with full HTML, making them SEO-friendly and faster.

---

### Q2. Explain File-Based Routing in Next.js

**Answer:**
In Next.js, the **folder structure defines the URL**. You don't need to configure a router like React Router.

**App Router (v13+):**
```
app/
‚îú‚îÄ‚îÄ page.tsx           ‚Üí /
‚îú‚îÄ‚îÄ about/
‚îÇ   ‚îî‚îÄ‚îÄ page.tsx       ‚Üí /about
‚îú‚îÄ‚îÄ blog/
‚îÇ   ‚îú‚îÄ‚îÄ page.tsx       ‚Üí /blog
‚îÇ   ‚îî‚îÄ‚îÄ [slug]/
‚îÇ       ‚îî‚îÄ‚îÄ page.tsx   ‚Üí /blog/my-post
```

**Dynamic Route Example:**
```tsx
// app/blog/[slug]/page.tsx
type Props = {
  params: { slug: string }
}

export default function BlogPost({ params }: Props) {
  return <h1>Blog Post: {params.slug}</h1>
}
```

**Real-World Scenario:**
> For a news website, each article has a unique URL like `/news/breaking-story-2024`. Just create `app/news/[slug]/page.tsx` and Next.js handles all article URLs automatically.

---

### Q3. What are Catch-All Routes?

**Answer:**
Catch-all routes match **multiple path segments** using `[...slug]`.

```
app/docs/[...slug]/page.tsx
```
This matches:
- `/docs/react`
- `/docs/react/hooks`
- `/docs/react/hooks/useEffect`

```tsx
// app/docs/[...slug]/page.tsx
export default function DocsPage({ params }: { params: { slug: string[] } }) {
  // params.slug = ['react', 'hooks', 'useEffect']
  return <div>Viewing: {params.slug.join(' > ')}</div>
}
```

**Real-World Scenario:**
> Documentation sites like Vercel docs use catch-all routes so `/docs/getting-started/installation` all resolves to one dynamic component.

---

## üñ•Ô∏è RENDERING STRATEGIES

---

### Q4. Explain SSR, SSG, ISR, and CSR ‚Äî when would you use each?

**Answer:**

| Strategy | When HTML is Created | Use When |
|---|---|---|
| SSR | Every request | Data changes frequently (user dashboard) |
| SSG | At build time | Data rarely changes (blog, docs) |
| ISR | Build time + revalidate | Semi-dynamic data (product catalog) |
| CSR | In the browser | Highly interactive UIs (chat apps) |

--

### Q5. How does SSR work in the App Router?

**Answer:**
Any `async` Server Component that fetches data is SSR by default.

```tsx
// app/dashboard/page.tsx
async function getUser() {
  const res = await fetch('https://api.example.com/user', {
    cache: 'no-store' // Opt out of caching = SSR
  })
  return res.json()
}

export default async function Dashboard() {
  const user = await getUser()
  return <h1>Welcome, {user.name}</h1>
}
```

**Real-World Scenario:**
> A banking dashboard shows live account balances. `cache: 'no-store'` ensures every page load fetches fresh data from the server.

---

### Q6. How does SSG work in Next.js?

**Answer:**
Pages are rendered at **build time**. Use `generateStaticParams` for dynamic SSG routes.

```tsx
// app/blog/[slug]/page.tsx

// Tells Next.js which slugs to pre-render at build time
export async function generateStaticParams() {
  const posts = await fetch('https://api.example.com/posts').then(r => r.json())
  return posts.map((post: any) => ({ slug: post.slug }))
}

export default async function BlogPost({ params }: { params: { slug: string } }) {
  const post = await fetch(`https://api.example.com/posts/${params.slug}`).then(r => r.json())
  return <article><h1>{post.title}</h1><p>{post.body}</p></article>
}
```

**Real-World Scenario:**
> A recipe website with 500 recipes. All pages are generated at build ‚Äî ultra-fast, no server needed, can be deployed to a CDN.

---

### Q7. What is ISR (Incremental Static Regeneration)?

**Answer:**
ISR combines the best of SSG (speed) and SSR (freshness). Pages are static but **auto-regenerate** after a set time.

```tsx
// app/products/[id]/page.tsx
export default async function Product({ params }: { params: { id: string } }) {
  const product = await fetch(`https://api.example.com/products/${params.id}`, {
    next: { revalidate: 60 } // Regenerate every 60 seconds
  }).then(r => r.json())

  return <div><h1>{product.name}</h1><p>Price: ${product.price}</p></div>
}
```

**Real-World Scenario:**
> An e-commerce product page. Prices change occasionally but not every second. ISR serves cached HTML (fast) and updates every 60 seconds in the background.

---

## ‚ö° SERVER COMPONENTS & CLIENT COMPONENTS

---

### Q8. What are React Server Components (RSC)?

**Answer:**
- Run **only on the server**, zero JS sent to the client
- Can use `async/await`, access databases, read files directly
- **Default** in the App Router

```tsx
// app/users/page.tsx ‚Äî Server Component (default)
import db from '@/lib/db'

export default async function UsersPage() {
  // Direct DB access ‚Äî no API needed!
  const users = await db.user.findMany()

  return (
    <ul>
      {users.map(user => <li key={user.id}>{user.name}</li>)}
    </ul>
  )
}
```

**Real-World Scenario:**
> An admin panel that lists all users. With RSC, you query the database directly in the component ‚Äî no need to build a separate API endpoint.

---

### Q9. When do you use `"use client"`?

**Answer:**
Use `"use client"` when you need:
- **State** (`useState`, `useReducer`)
- **Effects** (`useEffect`)
- **Browser APIs** (localStorage, window)
- **Event handlers** (onClick, onChange)
- **Third-party libraries** that use client APIs

```tsx
"use client"

import { useState } from 'react'

export default function Counter() {
  const [count, setCount] = useState(0)
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  )
}
```

**Real-World Scenario:**
> A "Add to Cart" button needs `onClick` and local state to track cart items ‚Äî must be a Client Component.

---

### Q10. Can you use a Server Component inside a Client Component?

**Answer:**
**No** ‚Äî but you can **pass a Server Component as a prop/children** to a Client Component.

```tsx
// ‚ùå Wrong ‚Äî importing Server Component inside Client Component
"use client"
import ServerComp from './ServerComp' // This gets converted to client

// ‚úÖ Correct ‚Äî pass as children
// layout.tsx (Server Component)
import ClientWrapper from './ClientWrapper'
import ServerData from './ServerData'

export default function Layout() {
  return (
    <ClientWrapper>
      <ServerData /> {/* Passed as children prop */}
    </ClientWrapper>
  )
}
```

---

## üîå API ROUTES

---

### Q11. How do you create an API Route in the App Router?

**Answer:**
Create a `route.ts` file inside `app/api/`.

```ts
// app/api/users/route.ts
import { NextRequest, NextResponse } from 'next/server'

// GET /api/users
export async function GET() {
  const users = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }]
  return NextResponse.json(users)
}

// POST /api/users
export async function POST(request: NextRequest) {
  const body = await request.json()
  // Save to DB...
  return NextResponse.json({ message: 'User created', data: body }, { status: 201 })
}
```

**Real-World Scenario:**
> A contact form on a portfolio site. The form POSTs to `/api/contact`, which sends an email via SendGrid ‚Äî all within the same Next.js app.

---

### Q12. How do you handle dynamic API routes?

```ts
// app/api/users/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server'

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const user = await db.user.findUnique({ where: { id: params.id } })
  if (!user) return NextResponse.json({ error: 'Not found' }, { status: 404 })
  return NextResponse.json(user)
}
```

---

## üñºÔ∏è OPTIMIZATIONS

---

### Q13. Explain the `next/image` component and its benefits

**Answer:**
`next/image` automatically:
- **Resizes** images to the right device size
- **Converts** to modern formats (WebP, AVIF)
- **Lazy loads** by default
- Prevents **Cumulative Layout Shift (CLS)**

```tsx
import Image from 'next/image'

export default function Hero() {
  return (
    <Image
      src="/hero.jpg"
      alt="Hero Image"
      width={1200}
      height={600}
      priority // Load eagerly for above-the-fold images
    />
  )
}
```

**Real-World Scenario:**
> A photography portfolio. Without optimization, loading 20 full-res photos would be slow. `next/image` serves small WebP versions to mobile users and larger ones to desktop.

---

### Q14. What is `next/font` and why is it better?

**Answer:**
`next/font` self-hosts fonts, eliminating external network requests to Google Fonts and preventing layout shift.

```tsx
// app/layout.tsx
import { Inter } from 'next/font/google'

const inter = Inter({
  subsets: ['latin'],
  variable: '--font-inter'
})

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en" className={inter.variable}>
      <body>{children}</body>
    </html>
  )
}
```

**Real-World Scenario:**
> Previously, every user's browser fetched fonts from `fonts.googleapis.com`, adding network latency. With `next/font`, fonts are bundled with your app ‚Äî zero extra requests.

---

## üõ°Ô∏è MIDDLEWARE

---

### Q15. What is Middleware in Next.js? Give a real-world use case.

**Answer:**
Middleware runs **before** the request reaches your page or API route. It runs at the **Edge** (close to the user).

```ts
// middleware.ts (root of project)
import { NextRequest, NextResponse } from 'next/server'
import { getToken } from 'next-auth/jwt'

export async function middleware(request: NextRequest) {
  const token = await getToken({ req: request })

  // Protect /dashboard routes
  if (!token && request.nextUrl.pathname.startsWith('/dashboard')) {
    return NextResponse.redirect(new URL('/login', request.url))
  }

  return NextResponse.next()
}

export const config = {
  matcher: ['/dashboard/:path*']
}
```

**Real-World Scenario:**
> A SaaS app where `/dashboard/*` is only accessible to logged-in users. Middleware redirects unauthenticated users to `/login` before the page even loads.

---

## üß≠ LAYOUTS

---

### Q16. What are Layouts in the App Router?

**Answer:**
Layouts wrap pages and **persist across navigation** without re-rendering. Defined via `layout.tsx`.

```tsx
// app/dashboard/layout.tsx
export default function DashboardLayout({ children }: { children: React.ReactNode }) {
  return (
    <div className="flex">
      <aside>
        <nav>
          <a href="/dashboard">Home</a>
          <a href="/dashboard/settings">Settings</a>
        </nav>
      </aside>
      <main className="flex-1">{children}</main>
    </div>
  )
}
```

**Real-World Scenario:**
> A dashboard app where the sidebar navigation stays visible regardless of which dashboard page the user visits. The sidebar is in `layout.tsx`, only the `{children}` changes.

---

## üîÑ STREAMING & SUSPENSE

---

### Q17. What is Streaming in Next.js?

**Answer:**
Streaming sends **parts of the page** to the browser as they're ready, instead of waiting for all data. Use `<Suspense>` to define loading boundaries.

```tsx
// app/dashboard/page.tsx
import { Suspense } from 'react'
import UserProfile from './UserProfile'
import RecentOrders from './RecentOrders'

export default function Dashboard() {
  return (
    <div>
      {/* Renders immediately */}
      <h1>Dashboard</h1>

      {/* Shows skeleton while data loads */}
      <Suspense fallback={<div>Loading profile...</div>}>
        <UserProfile /> {/* Slow API call */}
      </Suspense>

      <Suspense fallback={<div>Loading orders...</div>}>
        <RecentOrders /> {/* Another slow API call */}
      </Suspense>
    </div>
  )
}
```

**Real-World Scenario:**
> An analytics dashboard where each widget fetches from different APIs. With streaming, the page header appears instantly and each widget loads independently ‚Äî no spinner blocking the whole page.

---

## üóÉÔ∏è DATA FETCHING

---

### Q18. How does caching work in Next.js fetch?

**Answer:**
Next.js extends the native `fetch` with caching options:

```ts
// SSG ‚Äî cache forever (default)
fetch('https://api.example.com/data')
fetch('https://api.example.com/data', { cache: 'force-cache' })

// SSR ‚Äî no cache, fresh every request
fetch('https://api.example.com/data', { cache: 'no-store' })

// ISR ‚Äî revalidate every N seconds
fetch('https://api.example.com/data', { next: { revalidate: 60 } })
```

---

### Q19. What is `generateMetadata()` and how do you use it for dynamic SEO?

**Answer:**
`generateMetadata` generates page metadata **dynamically** based on data (perfect for dynamic routes).

```tsx
// app/blog/[slug]/page.tsx
import { Metadata } from 'next'

type Props = { params: { slug: string } }

export async function generateMetadata({ params }: Props): Promise<Metadata> {
  const post = await fetch(`https://api.example.com/posts/${params.slug}`).then(r => r.json())

  return {
    title: post.title,
    description: post.excerpt,
    openGraph: {
      title: post.title,
      images: [post.coverImage],
    },
  }
}

export default async function BlogPost({ params }: Props) {
  // ...
}
```

**Real-World Scenario:**
> Each blog post needs its own `<title>` and Open Graph image for social sharing. `generateMetadata` fetches the post data and returns unique meta tags per post.

---

## üöÄ ADVANCED

---

### Q20. What is the difference between `loading.tsx` and `<Suspense>`?

| | `loading.tsx` | `<Suspense>` |
|---|---|---|
| Scope | Entire page/route segment | Any component |
| Automatic | Yes (file convention) | No (manual) |
| Granularity | Coarse | Fine-grained |

```
app/
‚îú‚îÄ‚îÄ dashboard/
‚îÇ   ‚îú‚îÄ‚îÄ loading.tsx  ‚Üê Shows while dashboard/page.tsx loads
‚îÇ   ‚îî‚îÄ‚îÄ page.tsx
```

```tsx
// app/dashboard/loading.tsx
export default function Loading() {
  return <div className="skeleton">Loading dashboard...</div>
}
```

---

### Q21. How do Server Actions work?

**Answer:**
Server Actions allow you to run **server-side code directly from forms/components** ‚Äî no API route needed.

```tsx
// app/actions.ts
'use server'

import { revalidatePath } from 'next/cache'
import db from '@/lib/db'

export async function createPost(formData: FormData) {
  const title = formData.get('title') as string
  await db.post.create({ data: { title } })
  revalidatePath('/blog') // Refresh the blog page cache
}
```

```tsx
// app/new-post/page.tsx
import { createPost } from '@/app/actions'

export default function NewPost() {
  return (
    <form action={createPost}>
      <input name="title" placeholder="Post title" />
      <button type="submit">Create Post</button>
    </form>
  )
}
```

**Real-World Scenario:**
> A CMS where editors create new articles. Instead of: Form ‚Üí fetch('/api/posts') ‚Üí API route ‚Üí DB, you can go directly: Form ‚Üí Server Action ‚Üí DB.

---

### Q22. What is `revalidatePath` and `revalidateTag`?

**Answer:**
Used to **manually invalidate cached data** from Server Actions or API routes.

```ts
'use server'
import { revalidatePath, revalidateTag } from 'next/cache'

// Invalidate a specific page's cache
export async function updateProduct(id: string, data: any) {
  await db.product.update({ where: { id }, data })
  revalidatePath(`/products/${id}`) // Re-render that product page
}

// Invalidate all fetches tagged with 'products'
export async function deleteProduct(id: string) {
  await db.product.delete({ where: { id } })
  revalidateTag('products') // Re-fetch all tagged data
}
```

---

### Q23. How do you handle environment variables in Next.js?

```bash
# .env.local
DATABASE_URL=postgresql://...
NEXT_PUBLIC_API_URL=https://api.example.com  # Exposed to browser
SECRET_KEY=supersecret                        # Server only
```

```ts
// Server-side ‚Äî both work
const dbUrl = process.env.DATABASE_URL
const apiUrl = process.env.NEXT_PUBLIC_API_URL

// Client-side ‚Äî ONLY NEXT_PUBLIC_ works
const apiUrl = process.env.NEXT_PUBLIC_API_URL  // ‚úÖ
const secret = process.env.SECRET_KEY           // ‚ùå undefined
```

---

## üéØ QUICK-FIRE QUESTIONS

| Question | Answer |
|---|---|
| Default render in App Router? | Server Component |
| How to opt into SSR? | `cache: 'no-store'` in fetch |
| How to prevent page indexing? | `export const metadata = { robots: 'noindex' }` |
| What does `notFound()` do? | Returns a 404 page |
| What does `redirect()` do? | Server-side redirect |
| Where does middleware run? | Edge runtime, before the request |
| What is `use server`? | Marks a file/function as a Server Action |
| How to share layouts? | `layout.tsx` files in route segments |
| What is a Route Group? | Folder with `(name)` ‚Äî groups routes without affecting URL |
| What is a Parallel Route? | `@folder` ‚Äî render multiple pages in same layout |

---

## üí¨ Behavioral / Scenario Questions

**Q: "Describe a time you optimized a slow Next.js page."**
> Example answer: "Our product listing page was slow because it fetched 100 products on every request. I switched from SSR to ISR with a 5-minute revalidation window. Response times dropped from 800ms to under 50ms since pages were served from cache."

**Q: "How would you implement authentication in Next.js?"**
> Use **NextAuth.js** (now Auth.js). Protect routes via Middleware checking JWT tokens. Use Server Actions for sign-in/sign-out to avoid exposing sensitive logic to the client.

**Q: "How would you handle a form submission in Next.js?"**
> Use **Server Actions** ‚Äî define a `'use server'` function, bind it to a `<form action={}>`. For complex forms with validation, use React Hook Form on the client side and call a Server Action on submit.

---

*Happy Interviewing! üöÄ*
